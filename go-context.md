## Context Package
- Context package serves two primary purposes:
  - Provides API's for cancelling branches of call-graph.
  - Provides a data-bag for transporting request-scoped data through call-graph.
- `context.Background()` - returns an empty context, it is the root of any Context tree.
- Context is immutable
- The Context package provides functions to add new behavior.
- To add cancellation behavior we have functions like:
    - `context.WithCancel()`
    - `context.WithTimeout()`
    - `context.WithDeadline()`
- The derived context is passed to the children goroutines to facilitate their cancellation.
---

## Example Go Code using WithCancel context
- `WithCancel()` Examples and Explanations:
    - Creates a context that is cancellable
    - The `context.Background()` functions creates a root context.
    - The `context.WithCancel` is creating a cancellable context from the root context.
    - `ctx, cancel := context.WithCancel(context.Background())`
    - `defer cancel()`
    - `WithCancel` returns a copy of the parent context with a new 'Done' channel.
    - `cancel()` can be used to close the context's done channel.
    - Closing the done channel indicates to an operation to abandon its work and return.
    - Canceling the context releases the resources associated with it.
    - It's very important that we call the cancel function as soon as the operation running the context is complete.
    - If we don't, there will be a memory leak.
    - The resources that are associated with the context won't be released until the current context is cancelled or the parent context is cancelled.
    - `cancel()` does not wait for the work to stop.
    - `cancel()` may be called by multiple goroutines simultaneously.
    - After the first call, the subsequent calls to `cancel()` do nothing.
    - Full Example:
      - `ctx, cancel := context.WithCancel(context,Background())`
      - `ch := generator(ctx)`
      - `if n == 5 {`
      -   `cancel()`
      - `}` - This is the parent Goroutine
      - `for {`
      -   `select {`
      -   `case <-ctx.Done():`
      -    `return ctx.Err()`
      -    ` dst <- n:`
      -    `n++`
      -    `}`
      -   `}` - This is the child Goroutine
---

## Example Go Code using WithDeadline context
- `WithDeadline()` Examples and Explanations:
  - `deadline := time.Now().Add(5 * time.Millisecond)`
  - `ctx, cancel := context.WithDeadline(context.Background(), deadline)`
  - `defer cancel()`
  - `WithDeadline()` takes the parent context and clock time as input
  - `WithDeadline()` returns a new context that closes its done channel when the machine's clock advances past the given deadline.
  - `ctx.Deadline()` can be used to find out if a deadline is associated with the context.
  - `ok` is a boolean, it will be true if the deadline is set and false if otherwise.
  - Full Example:
    - `deadline, ok := ctx.Deadline()`
    - `if ok {`
    - `if deadline.Sub(time.Now().Add(10*time.Millisecond)) <= 0 {`
    - `return context.DeadlineExceeded`
    - `}`
    - `}` - Parent Go routine
    - `for {`
    - `select {`
    - `case <-ctx.Done():`
    - `return ctx.Err()`
    - `case dst <- n:`
    - `n++`
    - `}`
    - `}` - child Go routine
---

## Example Go Code using WithTimeout context
- `WithTimeout()` Examples and Explanations:
  - `duration := 5 * time.Millisecond`
  - `ctx, cancel := context.WithTimeout(context.Background(), duration)`
  - `defer cancel()`
  - `WithTimeout()` takes the parent context and a time duration as input
  - `WithTimeout()` returns a new context that closes its done channel after the given timeout duration.
  - `WithTimeout()` is useful for setting a deadline on the requests to backend servers.
  - `WithTimeout()` is a wrapper over `WithDeadline()`
  - `WithTimeout()` - timer count down begins from the moment the context is created.
  - `WithDeadline()` - Set explicit time when the timer will expire. We get more control over the timer expiration with this one.
---

## Example Go Code using WithValue context
- `context.WithValue()` provides a way to associate request-scoped values with a context.
   -  `type userIDType string`
   -  `ctx := context.WithValue(context.Background(), userIDType("userIDKey"), "jane")` - parent Go routine
   -  `userid := ctx.Value(userIDType("userIDKey")).(userIDType)` - child Go routine
- The context package can be used as a data bag to carry request-scoped data.
- `context.WithValue()` - used to associate request-scoped data with a context.
- `ctx.Value()` - is used to extract the value by giving it a key, and it will fetch the value from the context.
---